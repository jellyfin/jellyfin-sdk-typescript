/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 *
 * Jellyfin API
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BaseItemDto } from '../models';
// @ts-ignore
import type { BaseItemDtoQueryResult } from '../models';
// @ts-ignore
import type { ChannelMappingOptionsDto } from '../models';
// @ts-ignore
import type { ChannelType } from '../models';
// @ts-ignore
import type { GetProgramsDto } from '../models';
// @ts-ignore
import type { GuideInfo } from '../models';
// @ts-ignore
import type { ImageType } from '../models';
// @ts-ignore
import type { ItemFields } from '../models';
// @ts-ignore
import type { ItemSortBy } from '../models';
// @ts-ignore
import type { ListingsProviderInfo } from '../models';
// @ts-ignore
import type { LiveTvInfo } from '../models';
// @ts-ignore
import type { NameIdPair } from '../models';
// @ts-ignore
import type { ProblemDetails } from '../models';
// @ts-ignore
import type { RecordingStatus } from '../models';
// @ts-ignore
import type { SeriesTimerInfoDto } from '../models';
// @ts-ignore
import type { SeriesTimerInfoDtoQueryResult } from '../models';
// @ts-ignore
import type { SetChannelMappingDto } from '../models';
// @ts-ignore
import type { SortOrder } from '../models';
// @ts-ignore
import type { TimerInfoDto } from '../models';
// @ts-ignore
import type { TimerInfoDtoQueryResult } from '../models';
// @ts-ignore
import type { TunerChannelMapping } from '../models';
// @ts-ignore
import type { TunerHostInfo } from '../models';
/**
 * LiveTvApi - axios parameter creator
 * @export
 */
export const LiveTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider: async (pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (validateListings !== undefined) {
                localVarQueryParameter['validateListings'] = validateListings;
            }

            if (validateLogin !== undefined) {
                localVarQueryParameter['validateLogin'] = validateLogin;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listingsProviderInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost: async (tunerHostInfo?: TunerHostInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tunerHostInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer: async (timerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('cancelSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer: async (timerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('cancelTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer: async (seriesTimerInfoDto?: SeriesTimerInfoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seriesTimerInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (timerInfoDto?: TimerInfoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timerInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('deleteRecording', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners: async (newDevicesOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discvoverTuners: async (newDevicesOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getChannel', 'channelId', channelId)
            const localVarPath = `/LiveTv/Channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions: async (providerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer: async (programId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get guide info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups: async (id?: string, type?: string, location?: string, country?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile: async (recordingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getLiveRecordingFile', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/LiveRecordings/{recordingId}/stream`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile: async (streamId: string, container: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('getLiveStreamFile', 'streamId', streamId)
            // verify required parameter 'container' is not null or undefined
            assertParamExists('getLiveStreamFile', 'container', container)
            const localVarPath = `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels: async (type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<ItemSortBy>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['isLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['isDisliked'] = isDisliked;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['enableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['addCurrentProgram'] = addCurrentProgram;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {Array<string>} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
         * @param {Array<string>} [genres] The genres to return guide information for.
         * @param {Array<string>} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms: async (channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<ItemSortBy>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (channelIds) {
                localVarQueryParameter['channelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['minStartDate'] = (minStartDate as any instanceof Date) ?
                    (minStartDate as any).toISOString() :
                    minStartDate;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['maxStartDate'] = (maxStartDate as any instanceof Date) ?
                    (maxStartDate as any).toISOString() :
                    maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['minEndDate'] = (minEndDate as any instanceof Date) ?
                    (minEndDate as any).toISOString() :
                    minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['maxEndDate'] = (maxEndDate as any instanceof Date) ?
                    (maxEndDate as any).toISOString() :
                    maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (genres) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (librarySeriesId !== undefined) {
                localVarQueryParameter['librarySeriesId'] = librarySeriesId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgram', 'programId', programId)
            const localVarPath = `/LiveTv/Programs/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms: async (getProgramsDto?: GetProgramsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getProgramsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<string>} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms: async (userId?: string, startIndex?: number, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (genreIds) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording: async (recordingId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            assertParamExists('getRecording', 'recordingId', recordingId)
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getRecordingGroup', 'groupId', groupId)
            const localVarPath = `/LiveTv/Recordings/Groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingGroups: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings: async (channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isLibraryItem !== undefined) {
                localVarQueryParameter['isLibraryItem'] = isLibraryItem;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingsSeries: async (channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer: async (timerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('getSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers: async (sortBy?: string, sortOrder?: SortOrder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (timerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('getTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers: async (channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['isScheduled'] = isScheduled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner: async (tunerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunerId' is not null or undefined
            assertParamExists('resetTuner', 'tunerId', tunerId)
            const localVarPath = `/LiveTv/Tuners/{tunerId}/Reset`
                .replace(`{${"tunerId"}}`, encodeURIComponent(String(tunerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {SetChannelMappingDto} setChannelMappingDto The set channel mapping dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping: async (setChannelMappingDto: SetChannelMappingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setChannelMappingDto' is not null or undefined
            assertParamExists('setChannelMapping', 'setChannelMappingDto', setChannelMappingDto)
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setChannelMappingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer: async (timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('updateSeriesTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seriesTimerInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (timerId: string, timerInfoDto?: TimerInfoDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('updateTimer', 'timerId', timerId)
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timerInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvApi - functional programming interface
 * @export
 */
export const LiveTvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveTvApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.addListingProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTunerHost(tunerHostInfo?: TunerHostInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerHostInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTunerHost(tunerHostInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.addTunerHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeriesTimer(timerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSeriesTimer(timerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.cancelSeriesTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTimer(timerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTimer(timerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.cancelTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSeriesTimer(seriesTimerInfoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.createSeriesTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(timerInfoDto?: TimerInfoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimer(timerInfoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.createTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListingProvider(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListingProvider(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.deleteListingProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecording(recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.deleteRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunerHost(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTunerHost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.deleteTunerHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTuners(newDevicesOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverTuners(newDevicesOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.discoverTuners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discvoverTuners(newDevicesOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discvoverTuners(newDevicesOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.discvoverTuners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(channelId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getChannel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMappingOptions(providerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMappingOptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelMappingOptions(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getChannelMappingOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultListingProvider(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultListingProvider(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getDefaultListingProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTimer(programId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultTimer(programId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getDefaultTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get guide info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuideInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuideInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuideInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getGuideInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLineups(id?: string, type?: string, location?: string, country?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLineups(id, type, location, country, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLineups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveRecordingFile(recordingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveRecordingFile(recordingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLiveRecordingFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveStreamFile(streamId: string, container: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveStreamFile(streamId, container, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLiveStreamFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: Array<ItemSortBy>, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLiveTvChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLiveTvInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {Array<string>} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemSortBy>} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {Array<SortOrder>} [sortOrder] Sort Order - Ascending,Descending.
         * @param {Array<string>} [genres] The genres to return guide information for.
         * @param {Array<string>} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvPrograms(channelIds?: Array<string>, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: Array<ItemSortBy>, sortOrder?: Array<SortOrder>, genres?: Array<string>, genreIds?: Array<string>, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getLiveTvPrograms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgram(programId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getProgram']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrograms(getProgramsDto?: GetProgramsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrograms(getProgramsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getPrograms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<string>} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedPrograms(userId?: string, startIndex?: number, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: Array<string>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedPrograms(userId, startIndex, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecommendedPrograms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecording(recordingId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecording(recordingId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecording']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingFolders(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingFolders(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecordingFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRecordingGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecordingGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRecordingGroups(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingGroups(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecordingGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecordings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getRecordingsSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulesDirectCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedulesDirectCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getSchedulesDirectCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimer(timerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeriesTimer(timerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getSeriesTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSeriesTimers(sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getSeriesTimers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(timerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimer(timerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimers(channelId, seriesTimerId, isActive, isScheduled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getTimers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTunerHostTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTunerHostTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.getTunerHostTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuner(tunerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetTuner(tunerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.resetTuner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {SetChannelMappingDto} setChannelMappingDto The set channel mapping dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelMapping(setChannelMappingDto: SetChannelMappingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerChannelMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setChannelMapping(setChannelMappingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.setChannelMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSeriesTimer(timerId, seriesTimerInfoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.updateSeriesTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTimer(timerId, timerInfoDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveTvApi.updateTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveTvApi - factory interface
 * @export
 */
export const LiveTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveTvApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {LiveTvApiAddListingProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider(requestParameters: LiveTvApiAddListingProviderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListingsProviderInfo> {
            return localVarFp.addListingProvider(requestParameters.pw, requestParameters.validateListings, requestParameters.validateLogin, requestParameters.listingsProviderInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {LiveTvApiAddTunerHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost(requestParameters: LiveTvApiAddTunerHostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TunerHostInfo> {
            return localVarFp.addTunerHost(requestParameters.tunerHostInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {LiveTvApiCancelSeriesTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer(requestParameters: LiveTvApiCancelSeriesTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelSeriesTimer(requestParameters.timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {LiveTvApiCancelTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer(requestParameters: LiveTvApiCancelTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelTimer(requestParameters.timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {LiveTvApiCreateSeriesTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer(requestParameters: LiveTvApiCreateSeriesTimerRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSeriesTimer(requestParameters.seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {LiveTvApiCreateTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(requestParameters: LiveTvApiCreateTimerRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createTimer(requestParameters.timerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {LiveTvApiDeleteListingProviderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider(requestParameters: LiveTvApiDeleteListingProviderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteListingProvider(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {LiveTvApiDeleteRecordingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(requestParameters: LiveTvApiDeleteRecordingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecording(requestParameters.recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {LiveTvApiDeleteTunerHostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost(requestParameters: LiveTvApiDeleteTunerHostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTunerHost(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {LiveTvApiDiscoverTunersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners(requestParameters: LiveTvApiDiscoverTunersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TunerHostInfo>> {
            return localVarFp.discoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {LiveTvApiDiscvoverTunersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discvoverTuners(requestParameters: LiveTvApiDiscvoverTunersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<TunerHostInfo>> {
            return localVarFp.discvoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {LiveTvApiGetChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(requestParameters: LiveTvApiGetChannelRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDto> {
            return localVarFp.getChannel(requestParameters.channelId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {LiveTvApiGetChannelMappingOptionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions(requestParameters: LiveTvApiGetChannelMappingOptionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChannelMappingOptionsDto> {
            return localVarFp.getChannelMappingOptions(requestParameters.providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider(options?: RawAxiosRequestConfig): AxiosPromise<ListingsProviderInfo> {
            return localVarFp.getDefaultListingProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {LiveTvApiGetDefaultTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer(requestParameters: LiveTvApiGetDefaultTimerRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SeriesTimerInfoDto> {
            return localVarFp.getDefaultTimer(requestParameters.programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get guide info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo(options?: RawAxiosRequestConfig): AxiosPromise<GuideInfo> {
            return localVarFp.getGuideInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {LiveTvApiGetLineupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups(requestParameters: LiveTvApiGetLineupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<NameIdPair>> {
            return localVarFp.getLineups(requestParameters.id, requestParameters.type, requestParameters.location, requestParameters.country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {LiveTvApiGetLiveRecordingFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile(requestParameters: LiveTvApiGetLiveRecordingFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getLiveRecordingFile(requestParameters.recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {LiveTvApiGetLiveStreamFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile(requestParameters: LiveTvApiGetLiveStreamFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getLiveStreamFile(requestParameters.streamId, requestParameters.container, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {LiveTvApiGetLiveTvChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels(requestParameters: LiveTvApiGetLiveTvChannelsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getLiveTvChannels(requestParameters.type, requestParameters.userId, requestParameters.startIndex, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.limit, requestParameters.isFavorite, requestParameters.isLiked, requestParameters.isDisliked, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.enableFavoriteSorting, requestParameters.addCurrentProgram, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo(options?: RawAxiosRequestConfig): AxiosPromise<LiveTvInfo> {
            return localVarFp.getLiveTvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {LiveTvApiGetLiveTvProgramsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms(requestParameters: LiveTvApiGetLiveTvProgramsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getLiveTvPrograms(requestParameters.channelIds, requestParameters.userId, requestParameters.minStartDate, requestParameters.hasAired, requestParameters.isAiring, requestParameters.maxStartDate, requestParameters.minEndDate, requestParameters.maxEndDate, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.startIndex, requestParameters.limit, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.genres, requestParameters.genreIds, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.seriesTimerId, requestParameters.librarySeriesId, requestParameters.fields, requestParameters.enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {LiveTvApiGetProgramRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(requestParameters: LiveTvApiGetProgramRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDto> {
            return localVarFp.getProgram(requestParameters.programId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {LiveTvApiGetProgramsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms(requestParameters: LiveTvApiGetProgramsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getPrograms(requestParameters.getProgramsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {LiveTvApiGetRecommendedProgramsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms(requestParameters: LiveTvApiGetRecommendedProgramsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecommendedPrograms(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.isAiring, requestParameters.hasAired, requestParameters.isSeries, requestParameters.isMovie, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.genreIds, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {LiveTvApiGetRecordingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording(requestParameters: LiveTvApiGetRecordingRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDto> {
            return localVarFp.getRecording(requestParameters.recordingId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {LiveTvApiGetRecordingFoldersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders(requestParameters: LiveTvApiGetRecordingFoldersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingFolders(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recording group.
         * @param {LiveTvApiGetRecordingGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingGroup(requestParameters: LiveTvApiGetRecordingGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRecordingGroup(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {LiveTvApiGetRecordingGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingGroups(requestParameters: LiveTvApiGetRecordingGroupsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingGroups(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {LiveTvApiGetRecordingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings(requestParameters: LiveTvApiGetRecordingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordings(requestParameters.channelId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isKids, requestParameters.isSports, requestParameters.isNews, requestParameters.isLibraryItem, requestParameters.enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {LiveTvApiGetRecordingsSeriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRecordingsSeries(requestParameters: LiveTvApiGetRecordingsSeriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BaseItemDtoQueryResult> {
            return localVarFp.getRecordingsSeries(requestParameters.channelId, requestParameters.userId, requestParameters.groupId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getSchedulesDirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {LiveTvApiGetSeriesTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer(requestParameters: LiveTvApiGetSeriesTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<SeriesTimerInfoDto> {
            return localVarFp.getSeriesTimer(requestParameters.timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {LiveTvApiGetSeriesTimersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers(requestParameters: LiveTvApiGetSeriesTimersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SeriesTimerInfoDtoQueryResult> {
            return localVarFp.getSeriesTimers(requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {LiveTvApiGetTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(requestParameters: LiveTvApiGetTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<TimerInfoDto> {
            return localVarFp.getTimer(requestParameters.timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {LiveTvApiGetTimersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers(requestParameters: LiveTvApiGetTimersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TimerInfoDtoQueryResult> {
            return localVarFp.getTimers(requestParameters.channelId, requestParameters.seriesTimerId, requestParameters.isActive, requestParameters.isScheduled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<NameIdPair>> {
            return localVarFp.getTunerHostTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {LiveTvApiResetTunerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner(requestParameters: LiveTvApiResetTunerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetTuner(requestParameters.tunerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {LiveTvApiSetChannelMappingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping(requestParameters: LiveTvApiSetChannelMappingRequest, options?: RawAxiosRequestConfig): AxiosPromise<TunerChannelMapping> {
            return localVarFp.setChannelMapping(requestParameters.setChannelMappingDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {LiveTvApiUpdateSeriesTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer(requestParameters: LiveTvApiUpdateSeriesTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSeriesTimer(requestParameters.timerId, requestParameters.seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {LiveTvApiUpdateTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(requestParameters: LiveTvApiUpdateTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTimer(requestParameters.timerId, requestParameters.timerInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddListingProviderRequest
 */
export interface LiveTvApiAddListingProviderRequest {
    /**
     * Password.
     * @type {string}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly pw?: string

    /**
     * Validate listings.
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateListings?: boolean

    /**
     * Validate login.
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateLogin?: boolean

    /**
     * New listings info.
     * @type {ListingsProviderInfo}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly listingsProviderInfo?: ListingsProviderInfo
}

/**
 * Request parameters for addTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddTunerHostRequest
 */
export interface LiveTvApiAddTunerHostRequest {
    /**
     * New tuner host.
     * @type {TunerHostInfo}
     * @memberof LiveTvApiAddTunerHost
     */
    readonly tunerHostInfo?: TunerHostInfo
}

/**
 * Request parameters for cancelSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelSeriesTimerRequest
 */
export interface LiveTvApiCancelSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiCancelSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for cancelTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelTimerRequest
 */
export interface LiveTvApiCancelTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiCancelTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for createSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateSeriesTimerRequest
 */
export interface LiveTvApiCreateSeriesTimerRequest {
    /**
     * New series timer info.
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiCreateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for createTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateTimerRequest
 */
export interface LiveTvApiCreateTimerRequest {
    /**
     * New timer info.
     * @type {TimerInfoDto}
     * @memberof LiveTvApiCreateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * Request parameters for deleteListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteListingProviderRequest
 */
export interface LiveTvApiDeleteListingProviderRequest {
    /**
     * Listing provider id.
     * @type {string}
     * @memberof LiveTvApiDeleteListingProvider
     */
    readonly id?: string
}

/**
 * Request parameters for deleteRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteRecordingRequest
 */
export interface LiveTvApiDeleteRecordingRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiDeleteRecording
     */
    readonly recordingId: string
}

/**
 * Request parameters for deleteTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteTunerHostRequest
 */
export interface LiveTvApiDeleteTunerHostRequest {
    /**
     * Tuner host id.
     * @type {string}
     * @memberof LiveTvApiDeleteTunerHost
     */
    readonly id?: string
}

/**
 * Request parameters for discoverTuners operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDiscoverTunersRequest
 */
export interface LiveTvApiDiscoverTunersRequest {
    /**
     * Only discover new tuners.
     * @type {boolean}
     * @memberof LiveTvApiDiscoverTuners
     */
    readonly newDevicesOnly?: boolean
}

/**
 * Request parameters for discvoverTuners operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDiscvoverTunersRequest
 */
export interface LiveTvApiDiscvoverTunersRequest {
    /**
     * Only discover new tuners.
     * @type {boolean}
     * @memberof LiveTvApiDiscvoverTuners
     */
    readonly newDevicesOnly?: boolean
}

/**
 * Request parameters for getChannel operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelRequest
 */
export interface LiveTvApiGetChannelRequest {
    /**
     * Channel id.
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly channelId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly userId?: string
}

/**
 * Request parameters for getChannelMappingOptions operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelMappingOptionsRequest
 */
export interface LiveTvApiGetChannelMappingOptionsRequest {
    /**
     * Provider id.
     * @type {string}
     * @memberof LiveTvApiGetChannelMappingOptions
     */
    readonly providerId?: string
}

/**
 * Request parameters for getDefaultTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetDefaultTimerRequest
 */
export interface LiveTvApiGetDefaultTimerRequest {
    /**
     * Optional. To attach default values based on a program.
     * @type {string}
     * @memberof LiveTvApiGetDefaultTimer
     */
    readonly programId?: string
}

/**
 * Request parameters for getLineups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLineupsRequest
 */
export interface LiveTvApiGetLineupsRequest {
    /**
     * Provider id.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly id?: string

    /**
     * Provider type.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly type?: string

    /**
     * Location.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly location?: string

    /**
     * Country.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly country?: string
}

/**
 * Request parameters for getLiveRecordingFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveRecordingFileRequest
 */
export interface LiveTvApiGetLiveRecordingFileRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiGetLiveRecordingFile
     */
    readonly recordingId: string
}

/**
 * Request parameters for getLiveStreamFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveStreamFileRequest
 */
export interface LiveTvApiGetLiveStreamFileRequest {
    /**
     * Stream id.
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly streamId: string

    /**
     * Container type.
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly container: string
}

/**
 * Request parameters for getLiveTvChannels operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvChannelsRequest
 */
export interface LiveTvApiGetLiveTvChannelsRequest {
    /**
     * Optional. Filter by channel type.
     * @type {ChannelType}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly type?: ChannelType

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly startIndex?: number

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSports?: boolean

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly limit?: number

    /**
     * Optional. Filter by channels that are favorites, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isFavorite?: boolean

    /**
     * Optional. Filter by channels that are liked, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isLiked?: boolean

    /**
     * Optional. Filter by channels that are disliked, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isDisliked?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly imageTypeLimit?: number

    /**
     * \&quot;Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Key to sort by.
     * @type {Array<ItemSortBy>}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortBy?: Array<ItemSortBy>

    /**
     * Optional. Sort order.
     * @type {SortOrder}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortOrder?: SortOrder

    /**
     * Optional. Incorporate favorite and like status into channel sorting.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableFavoriteSorting?: boolean

    /**
     * Optional. Adds current program info to each channel.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly addCurrentProgram?: boolean
}

/**
 * Request parameters for getLiveTvPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvProgramsRequest
 */
export interface LiveTvApiGetLiveTvProgramsRequest {
    /**
     * The channels to return guide information for.
     * @type {Array<string>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly channelIds?: Array<string>

    /**
     * Optional. Filter by user id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly userId?: string

    /**
     * Optional. The minimum premiere start date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minStartDate?: string

    /**
     * Optional. Filter by programs that have completed airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly hasAired?: boolean

    /**
     * Optional. Filter by programs that are currently airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isAiring?: boolean

    /**
     * Optional. The maximum premiere start date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxStartDate?: string

    /**
     * Optional. The minimum premiere end date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minEndDate?: string

    /**
     * Optional. The maximum premiere end date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxEndDate?: string

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSports?: boolean

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly limit?: number

    /**
     * Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
     * @type {Array<ItemSortBy>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortBy?: Array<ItemSortBy>

    /**
     * Sort Order - Ascending,Descending.
     * @type {Array<SortOrder>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortOrder?: Array<SortOrder>

    /**
     * The genres to return guide information for.
     * @type {Array<string>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genres?: Array<string>

    /**
     * The genre ids to return guide information for.
     * @type {Array<string>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genreIds?: Array<string>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Filter by series timer id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Filter by library series id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly librarySeriesId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly fields?: Array<ItemFields>

    /**
     * Retrieve total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getProgram operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramRequest
 */
export interface LiveTvApiGetProgramRequest {
    /**
     * Program id.
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly programId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly userId?: string
}

/**
 * Request parameters for getPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramsRequest
 */
export interface LiveTvApiGetProgramsRequest {
    /**
     * Request body.
     * @type {GetProgramsDto}
     * @memberof LiveTvApiGetPrograms
     */
    readonly getProgramsDto?: GetProgramsDto
}

/**
 * Request parameters for getRecommendedPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecommendedProgramsRequest
 */
export interface LiveTvApiGetRecommendedProgramsRequest {
    /**
     * Optional. filter by user id.
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly limit?: number

    /**
     * Optional. Filter by programs that are currently airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isAiring?: boolean

    /**
     * Optional. Filter by programs that have completed airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly hasAired?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSports?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * The genres to return guide information for.
     * @type {Array<string>}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly genreIds?: Array<string>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableUserData?: boolean

    /**
     * Retrieve total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingRequest
 */
export interface LiveTvApiGetRecordingRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly recordingId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingFolders operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingFoldersRequest
 */
export interface LiveTvApiGetRecordingFoldersRequest {
    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingFolders
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingGroup operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupRequest
 */
export interface LiveTvApiGetRecordingGroupRequest {
    /**
     * Group id.
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for getRecordingGroups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupsRequest
 */
export interface LiveTvApiGetRecordingGroupsRequest {
    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroups
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordings operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsRequest
 */
export interface LiveTvApiGetRecordingsRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly channelId?: string

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly limit?: number

    /**
     * Optional. Filter by recording status.
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordings
     */
    readonly status?: RecordingStatus

    /**
     * Optional. Filter by recordings that are in progress, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isInProgress?: boolean

    /**
     * Optional. Filter by recordings belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecordings
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSports?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for is library item.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isLibraryItem?: boolean

    /**
     * Optional. Return total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecordingsSeries operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsSeriesRequest
 */
export interface LiveTvApiGetRecordingsSeriesRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly channelId?: string

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly userId?: string

    /**
     * Optional. Filter by recording group.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly groupId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly limit?: number

    /**
     * Optional. Filter by recording status.
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly status?: RecordingStatus

    /**
     * Optional. Filter by recordings that are in progress, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly isInProgress?: boolean

    /**
     * Optional. Filter by recordings belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Return total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimerRequest
 */
export interface LiveTvApiGetSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getSeriesTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimersRequest
 */
export interface LiveTvApiGetSeriesTimersRequest {
    /**
     * Optional. Sort by SortName or Priority.
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortBy?: string

    /**
     * Optional. Sort in Ascending or Descending order.
     * @type {SortOrder}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortOrder?: SortOrder
}

/**
 * Request parameters for getTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimerRequest
 */
export interface LiveTvApiGetTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiGetTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimersRequest
 */
export interface LiveTvApiGetTimersRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly channelId?: string

    /**
     * Optional. Filter by timers belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Filter by timers that are active.
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isActive?: boolean

    /**
     * Optional. Filter by timers that are scheduled.
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isScheduled?: boolean
}

/**
 * Request parameters for resetTuner operation in LiveTvApi.
 * @export
 * @interface LiveTvApiResetTunerRequest
 */
export interface LiveTvApiResetTunerRequest {
    /**
     * Tuner id.
     * @type {string}
     * @memberof LiveTvApiResetTuner
     */
    readonly tunerId: string
}

/**
 * Request parameters for setChannelMapping operation in LiveTvApi.
 * @export
 * @interface LiveTvApiSetChannelMappingRequest
 */
export interface LiveTvApiSetChannelMappingRequest {
    /**
     * The set channel mapping dto.
     * @type {SetChannelMappingDto}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly setChannelMappingDto: SetChannelMappingDto
}

/**
 * Request parameters for updateSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateSeriesTimerRequest
 */
export interface LiveTvApiUpdateSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly timerId: string

    /**
     * New series timer info.
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for updateTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateTimerRequest
 */
export interface LiveTvApiUpdateTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerId: string

    /**
     * New timer info.
     * @type {TimerInfoDto}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * LiveTvApi - object-oriented interface
 * @export
 * @class LiveTvApi
 * @extends {BaseAPI}
 */
export class LiveTvApi extends BaseAPI {
    /**
     * 
     * @summary Adds a listings provider.
     * @param {LiveTvApiAddListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addListingProvider(requestParameters: LiveTvApiAddListingProviderRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).addListingProvider(requestParameters.pw, requestParameters.validateListings, requestParameters.validateLogin, requestParameters.listingsProviderInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a tuner host.
     * @param {LiveTvApiAddTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addTunerHost(requestParameters: LiveTvApiAddTunerHostRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).addTunerHost(requestParameters.tunerHostInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv series timer.
     * @param {LiveTvApiCancelSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelSeriesTimer(requestParameters: LiveTvApiCancelSeriesTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).cancelSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv timer.
     * @param {LiveTvApiCancelTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelTimer(requestParameters: LiveTvApiCancelTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).cancelTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv series timer.
     * @param {LiveTvApiCreateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createSeriesTimer(requestParameters: LiveTvApiCreateSeriesTimerRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).createSeriesTimer(requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv timer.
     * @param {LiveTvApiCreateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createTimer(requestParameters: LiveTvApiCreateTimerRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).createTimer(requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete listing provider.
     * @param {LiveTvApiDeleteListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteListingProvider(requestParameters: LiveTvApiDeleteListingProviderRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).deleteListingProvider(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a live tv recording.
     * @param {LiveTvApiDeleteRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteRecording(requestParameters: LiveTvApiDeleteRecordingRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).deleteRecording(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a tuner host.
     * @param {LiveTvApiDeleteTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteTunerHost(requestParameters: LiveTvApiDeleteTunerHostRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).deleteTunerHost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {LiveTvApiDiscoverTunersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discoverTuners(requestParameters: LiveTvApiDiscoverTunersRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).discoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {LiveTvApiDiscvoverTunersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discvoverTuners(requestParameters: LiveTvApiDiscvoverTunersRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).discvoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel.
     * @param {LiveTvApiGetChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannel(requestParameters: LiveTvApiGetChannelRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getChannel(requestParameters.channelId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel mapping options.
     * @param {LiveTvApiGetChannelMappingOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannelMappingOptions(requestParameters: LiveTvApiGetChannelMappingOptionsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getChannelMappingOptions(requestParameters.providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets default listings provider info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultListingProvider(options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getDefaultListingProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default values for a new timer.
     * @param {LiveTvApiGetDefaultTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultTimer(requestParameters: LiveTvApiGetDefaultTimerRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getDefaultTimer(requestParameters.programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get guide info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getGuideInfo(options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getGuideInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available lineups.
     * @param {LiveTvApiGetLineupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLineups(requestParameters: LiveTvApiGetLineupsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLineups(requestParameters.id, requestParameters.type, requestParameters.location, requestParameters.country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording stream.
     * @param {LiveTvApiGetLiveRecordingFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveRecordingFile(requestParameters: LiveTvApiGetLiveRecordingFileRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLiveRecordingFile(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel stream.
     * @param {LiveTvApiGetLiveStreamFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveStreamFile(requestParameters: LiveTvApiGetLiveStreamFileRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLiveStreamFile(requestParameters.streamId, requestParameters.container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv channels.
     * @param {LiveTvApiGetLiveTvChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvChannels(requestParameters: LiveTvApiGetLiveTvChannelsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLiveTvChannels(requestParameters.type, requestParameters.userId, requestParameters.startIndex, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.limit, requestParameters.isFavorite, requestParameters.isLiked, requestParameters.isDisliked, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.enableFavoriteSorting, requestParameters.addCurrentProgram, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvInfo(options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLiveTvInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {LiveTvApiGetLiveTvProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvPrograms(requestParameters: LiveTvApiGetLiveTvProgramsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getLiveTvPrograms(requestParameters.channelIds, requestParameters.userId, requestParameters.minStartDate, requestParameters.hasAired, requestParameters.isAiring, requestParameters.maxStartDate, requestParameters.minEndDate, requestParameters.maxEndDate, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.startIndex, requestParameters.limit, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.genres, requestParameters.genreIds, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.seriesTimerId, requestParameters.librarySeriesId, requestParameters.fields, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv program.
     * @param {LiveTvApiGetProgramRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getProgram(requestParameters: LiveTvApiGetProgramRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getProgram(requestParameters.programId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {LiveTvApiGetProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getPrograms(requestParameters: LiveTvApiGetProgramsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getPrograms(requestParameters.getProgramsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recommended live tv epgs.
     * @param {LiveTvApiGetRecommendedProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecommendedPrograms(requestParameters: LiveTvApiGetRecommendedProgramsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecommendedPrograms(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.isAiring, requestParameters.hasAired, requestParameters.isSeries, requestParameters.isMovie, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.genreIds, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording.
     * @param {LiveTvApiGetRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecording(requestParameters: LiveTvApiGetRecordingRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecording(requestParameters.recordingId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recording folders.
     * @param {LiveTvApiGetRecordingFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingFolders(requestParameters: LiveTvApiGetRecordingFoldersRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecordingFolders(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recording group.
     * @param {LiveTvApiGetRecordingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroup(requestParameters: LiveTvApiGetRecordingGroupRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecordingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording groups.
     * @param {LiveTvApiGetRecordingGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroups(requestParameters: LiveTvApiGetRecordingGroupsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecordingGroups(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recordings.
     * @param {LiveTvApiGetRecordingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordings(requestParameters: LiveTvApiGetRecordingsRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecordings(requestParameters.channelId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isKids, requestParameters.isSports, requestParameters.isNews, requestParameters.isLibraryItem, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording series.
     * @param {LiveTvApiGetRecordingsSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingsSeries(requestParameters: LiveTvApiGetRecordingsSeriesRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getRecordingsSeries(requestParameters.channelId, requestParameters.userId, requestParameters.groupId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSchedulesDirectCountries(options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getSchedulesDirectCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv series timer.
     * @param {LiveTvApiGetSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimer(requestParameters: LiveTvApiGetSeriesTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv series timers.
     * @param {LiveTvApiGetSeriesTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimers(requestParameters: LiveTvApiGetSeriesTimersRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getSeriesTimers(requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a timer.
     * @param {LiveTvApiGetTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimer(requestParameters: LiveTvApiGetTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the live tv timers.
     * @param {LiveTvApiGetTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimers(requestParameters: LiveTvApiGetTimersRequest = {}, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getTimers(requestParameters.channelId, requestParameters.seriesTimerId, requestParameters.isActive, requestParameters.isScheduled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tuner host types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTunerHostTypes(options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).getTunerHostTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets a tv tuner.
     * @param {LiveTvApiResetTunerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public resetTuner(requestParameters: LiveTvApiResetTunerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).resetTuner(requestParameters.tunerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set channel mappings.
     * @param {LiveTvApiSetChannelMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public setChannelMapping(requestParameters: LiveTvApiSetChannelMappingRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).setChannelMapping(requestParameters.setChannelMappingDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv series timer.
     * @param {LiveTvApiUpdateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateSeriesTimer(requestParameters: LiveTvApiUpdateSeriesTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).updateSeriesTimer(requestParameters.timerId, requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv timer.
     * @param {LiveTvApiUpdateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateTimer(requestParameters: LiveTvApiUpdateTimerRequest, options?: RawAxiosRequestConfig) {
        return LiveTvApiFp(this.configuration).updateTimer(requestParameters.timerId, requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}

